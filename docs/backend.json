{
  "entities": {
    "UserAccount": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserAccount",
      "type": "object",
      "description": "Stores user account information for registration and login.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user account."
        },
        "username": {
          "type": "string",
          "description": "The user's chosen username for login."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "phoneNumber": {
          "type": "string",
          "description": "The user's phone number for contact and alerts."
        },
        "registrationDate": {
          "type": "string",
          "description": "The date and time the user registered.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "username",
        "email"
      ]
    },
    "Medication": {
      "title": "Medication",
      "type": "object",
      "description": "Represents a user's medication, including dosage and schedule.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the medication."
        },
        "dosage": {
          "type": "string",
          "description": "The prescribed dosage (e.g., '10mg', '1 tablet')."
        },
        "timings": {
          "type": "array",
          "items": {
            "type": "string",
            "description": "Scheduled times for doses in HH:mm format."
          }
        },
        "status": {
          "type": "string",
          "description": "Current status of the next dose.",
          "enum": ["Upcoming", "Taken", "Snoozed", "Missed"]
        },
        "nextDoseTime": {
          "type": "string",
          "description": "The next scheduled dose time in HH:mm format.",
          "format": "time"
        },
        "nextDoseDate": {
            "type": "string",
            "description": "The exact date and time for the next dose.",
            "format": "date-time"
        },
        "userId": {
            "type": "string",
            "description": "The ID of the user this medication belongs to."
        }
      },
      "required": ["name", "dosage", "timings", "userId"]
    },
    "MedicationLog": {
        "title": "MedicationLog",
        "type": "object",
        "description": "A log entry for a medication event (taken, snoozed, missed).",
        "properties": {
            "userId": {
                "type": "string",
                "description": "The ID of the user."
            },
            "medicationId": {
                "type": "string",
                "description": "The ID of the medication."
            },
            "medicationName": {
                "type": "string",
                "description": "The name of the medication."
            },
            "status": {
                "type": "string",
                "description": "The status of the medication event.",
                "enum": ["Taken", "Snoozed", "Missed"]
            },
            "timestamp": {
                "type": "string",
                "description": "When the event occurred.",
                "format": "date-time"
            }
        },
        "required": ["userId", "medicationId", "medicationName", "status", "timestamp"]
    },
    "MedicalReport": {
        "title": "MedicalReport",
        "type": "object",
        "description": "Metadata for an uploaded medical report.",
        "properties": {
            "userId": {
                "type": "string",
                "description": "The ID of the user who owns the report."
            },
            "fileName": {
                "type": "string",
                "description": "The original name of the uploaded file."
            },
            "fileType": {
                "type": "string",
                "description": "The MIME type of the file (e.g., 'application/pdf')."
            },
            "fileSize": {
                "type": "number",
                "description": "The size of the file in bytes."
            },
            "uploadDate": {
                "type": "string",
                "description": "The date and time the report was uploaded.",
                "format": "date-time"
            },
            "storagePath": {
                "type": "string",
                "description": "The path to the file in Firebase Storage."
            }
        },
        "required": ["userId", "fileName", "fileType", "fileSize", "uploadDate", "storagePath"]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "UserAccount",
          "schema": {
            "$ref": "#/backend/entities/UserAccount"
          },
          "description": "Stores user account information. User ID is used for path-based ownership.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user, obtained from Firebase Authentication."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/medications/{medicationId}",
        "definition": {
          "entityName": "Medication",
          "schema": {
            "$ref": "#/backend/entities/Medication"
          },
          "description": "Stores individual medications for a user.",
          "params": [
             {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "medicationId",
              "description": "The unique ID of the medication."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/medicationlogs/{logId}",
        "definition": {
            "entityName": "MedicationLog",
            "schema": {
                "$ref": "#/backend/entities/MedicationLog"
            },
            "description": "Stores logs of medication consumption for a user.",
             "params": [
             {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "logId",
              "description": "The unique ID of the log entry."
            }
          ]
        }
      },
       {
        "path": "/users/{userId}/reports/{reportId}",
        "definition": {
            "entityName": "MedicalReport",
            "schema": {
                "$ref": "#/backend/entities/MedicalReport"
            },
            "description": "Stores metadata for user-uploaded medical reports.",
             "params": [
             {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "reportId",
              "description": "The unique ID of the report metadata document."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to support the MediCare Assist application, focusing on secure user authentication, prescription management, medication tracking, and caregiver alerts. The core principle is Authorization Independence, achieved by storing user-specific data under their respective user IDs, eliminating the need for `get()` calls in security rules and ensuring atomic operations. Segregation is used to maintain homogeneous security postures for different data types.\n\nSpecifically, each user's data (account, prescriptions, medication records) is stored under `/users/{userId}`. This path-based ownership simplifies security rules, ensuring only the authenticated user can access their data. The AI-generated dashboard and medication tracking data are stored under this path to enforce ownership and maintain data privacy. The caregiver alerts might require a separate function triggered by changes in medication status, and direct access to caregiver data would follow a similar pattern if needed. The emergency button functionality might involve writing to a separate collection (e.g., `/emergency_requests`), which can be accessed by authorized personnel, potentially using a dedicated service account.\n\nThis design supports the QAPs by: \n1. Providing secure `list` operations: Rules can restrict listing to the authenticated user's data.\n2. Enforcing strict ownership: User data is isolated to their respective paths.\n3. Enabling straightforward security rule definitions: Rules can directly verify `request.auth.uid` against the path parameters, guaranteeing only the intended user can access the data."
  }
}
